// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package storages

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO
    users (
        username,
        first_name,
        last_name,
        email,
        passwhash,
        is_active,
        created_at
    )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING
    username,
    first_name,
    last_name,
    email
`

type CreateUserParams struct {
	Username  string
	FirstName string
	LastName  string
	Email     string
	Passwhash string
	IsActive  bool
	CreatedAt pgtype.Timestamptz
}

type CreateUserRow struct {
	Username  string
	FirstName string
	LastName  string
	Email     string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Passwhash,
		arg.IsActive,
		arg.CreatedAt,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.Email,
	)
	return i, err
}

const deactivateTokenSession = `-- name: DeactivateTokenSession :exec
UPDATE
    users_sessions
SET
    is_active = FALSE,
    used_at = $1
WHERE
    user_id = $2
`

type DeactivateTokenSessionParams struct {
	UsedAt pgtype.Timestamptz
	UserID int32
}

func (q *Queries) DeactivateTokenSession(ctx context.Context, arg DeactivateTokenSessionParams) error {
	_, err := q.db.Exec(ctx, deactivateTokenSession, arg.UsedAt, arg.UserID)
	return err
}

const getUserCredentialByEmail = `-- name: GetUserCredentialByEmail :one
SELECT
    user_id,
    username,
    email,
    passwhash
FROM
    users
WHERE
    email = $1 AND deleted_at IS NULL
`

type GetUserCredentialByEmailRow struct {
	UserID    int32
	Username  string
	Email     string
	Passwhash string
}

func (q *Queries) GetUserCredentialByEmail(ctx context.Context, email string) (GetUserCredentialByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserCredentialByEmail, email)
	var i GetUserCredentialByEmailRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.Passwhash,
	)
	return i, err
}

const insertTokenSession = `-- name: InsertTokenSession :one
INSERT INTO
    users_sessions (
        user_id,
        token,
        created_at,
        is_active
    )
VALUES ($1, $2, $3, $4)
RETURNING
    users_sessions_id, user_id, token, created_at, is_active, used_at
`

type InsertTokenSessionParams struct {
	UserID    int32
	Token     string
	CreatedAt pgtype.Timestamptz
	IsActive  bool
}

func (q *Queries) InsertTokenSession(ctx context.Context, arg InsertTokenSessionParams) (UsersSession, error) {
	row := q.db.QueryRow(ctx, insertTokenSession,
		arg.UserID,
		arg.Token,
		arg.CreatedAt,
		arg.IsActive,
	)
	var i UsersSession
	err := row.Scan(
		&i.UsersSessionsID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
		&i.IsActive,
		&i.UsedAt,
	)
	return i, err
}
